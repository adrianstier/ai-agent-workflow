import { Router, Request, Response } from 'express';
import { exec } from 'child_process';
import { promisify } from 'util';
import * as fs from 'fs/promises';
import * as path from 'path';
import { Octokit } from '@octokit/rest';

const execAsync = promisify(exec);
const router = Router();

interface ProjectForm {
  name: string;
  description: string;
  problemStatement: string;
  targetUsers: string;
  keyFeatures: string;
  techStack: string;
  timeline: string;
  additionalNotes: string;
  createGithubRepo: boolean;
  repoVisibility: 'public' | 'private';
}

// Helper to sanitize project name
function sanitizeProjectName(name: string): string {
  return name
    .toLowerCase()
    .replace(/[^a-z0-9-]/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
}

// Generate PROJECT_BRIEF.md content
function generateProjectBrief(form: ProjectForm): string {
  const features = form.keyFeatures
    .split('\n')
    .filter((f) => f.trim())
    .map((f) => f.trim().replace(/^-\s*/, ''))
    .map((f, i) => `${i + 1}. [ ] ${f}`)
    .join('\n');

  return `# Project Brief: ${form.name}

## Executive Summary

${form.description}

## Problem Statement

${form.problemStatement}

## Target Users

${form.targetUsers}

## Key Features

### Must Have (MVP)
${features}

### Should Have
1. [ ] Additional feature TBD
2. [ ] Additional feature TBD

### Nice to Have
1. [ ] Future enhancement TBD

## Success Criteria

- [ ] Core functionality works as described
- [ ] User can complete primary workflow
- [ ] Performance meets requirements
- [ ] Tests pass with >80% coverage

## Technical Requirements

### Stack Preferences
${form.techStack || 'To be determined based on requirements'}

### Constraints
${form.timeline ? `- Timeline: ${form.timeline}` : '- Timeline: To be determined'}
- Budget: To be determined
- Other constraints: To be determined

## User Stories

### As a [user type], I want to [action] so that [benefit]

1. As a user, I want to ${form.keyFeatures.split('\n')[0]?.replace(/^-\s*/, '') || 'complete the primary action'} so that I can achieve my goal
2. Additional user stories to be defined

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Technical complexity | Medium | Break into smaller tasks, prototype early |
| Scope creep | High | Stick to MVP features first |
| Timeline pressure | Medium | Prioritize ruthlessly |

## Timeline

${form.timeline || 'To be determined'}

## Additional Notes

${form.additionalNotes || 'None provided'}

---

*Generated by AI Agent Workflow System*
`;
}

// Generate README.md content
function generateReadme(form: ProjectForm): string {
  return `# ${form.name}

${form.description}

## Overview

${form.problemStatement}

## Features

${form.keyFeatures
  .split('\n')
  .filter((f) => f.trim())
  .map((f) => `- ${f.trim().replace(/^-\s*/, '')}`)
  .join('\n')}

## Getting Started

### Prerequisites

${form.techStack ? `- ${form.techStack.split(',').join('\n- ')}` : '- To be determined'}

### Installation

\`\`\`bash
# Clone the repository
git clone https://github.com/yourusername/${sanitizeProjectName(form.name)}.git
cd ${sanitizeProjectName(form.name)}

# Install dependencies
# [Add installation commands based on tech stack]
\`\`\`

### Usage

\`\`\`bash
# [Add usage commands]
\`\`\`

## Development

This project uses an AI agent workflow for structured development.

### AI Agent Workflow

The \`agents/\` folder contains 10 specialized AI agents to guide development:

| Agent | Role |
|-------|------|
| 0 - Orchestrator | Coordinates the overall workflow |
| 1 - Problem Framer | Defines requirements and scope |
| 2 - Competitive Mapper | Research and market analysis |
| 3 - Product Manager | Feature specs and user stories |
| 4 - UX Designer | UI/UX design |
| 5 - System Architect | Technical architecture |
| 6 - Engineer | Implementation |
| 7 - QA Test Engineer | Testing and quality |
| 8 - DevOps | Deployment and CI/CD |
| 9 - Analytics | Metrics and growth |

### Getting Started with Agents

1. Review \`PROJECT_BRIEF.md\` for requirements
2. Start with \`agents/agent-0-orchestrator.md\`
3. Follow agents in sequence for structured development

## Project Structure

\`\`\`
${sanitizeProjectName(form.name)}/
â”œâ”€â”€ agents/           # AI development workflow
â”œâ”€â”€ src/              # Source code
â”œâ”€â”€ tests/            # Test files
â”œâ”€â”€ docs/             # Documentation
â”œâ”€â”€ data/             # Data and configs
â”œâ”€â”€ PROJECT_BRIEF.md  # Project requirements
â””â”€â”€ README.md         # This file
\`\`\`

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Submit a pull request

## License

MIT License - see LICENSE for details

---

*Generated by AI Agent Workflow System*
`;
}

// Generate .gitignore content
function generateGitignore(): string {
  return `# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
dist/
*.egg-info/
venv/
env/
.venv/

# Node
node_modules/
.next/
out/
.nuxt/
dist/

# IDE
.idea/
.vscode/
*.swp
*.swo

# Testing
.pytest_cache/
.coverage
htmlcov/
coverage/

# OS
.DS_Store
Thumbs.db

# Environment
.env
.env.local
.env*.local

# Project specific
data/personal/
output/
*.log
`;
}

// Main project generation endpoint
router.post('/generate-project', async (req: Request, res: Response) => {
  const form: ProjectForm = req.body;

  try {
    // Validate required fields
    if (!form.name || !form.description || !form.problemStatement || !form.targetUsers || !form.keyFeatures) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const projectName = sanitizeProjectName(form.name);
    const projectPath = path.join(process.env.HOME || '/tmp', 'Desktop', projectName);

    // Check if directory already exists
    try {
      await fs.access(projectPath);
      return res.status(400).json({ error: `Directory already exists: ${projectPath}` });
    } catch {
      // Directory doesn't exist, which is what we want
    }

    // Create project directory structure
    await fs.mkdir(projectPath, { recursive: true });
    await fs.mkdir(path.join(projectPath, 'src'), { recursive: true });
    await fs.mkdir(path.join(projectPath, 'tests'), { recursive: true });
    await fs.mkdir(path.join(projectPath, 'docs'), { recursive: true });
    await fs.mkdir(path.join(projectPath, 'data'), { recursive: true });

    // Copy agents folder
    const agentsSource = path.join(__dirname, '..', '..', '..', '..', 'agents');
    const agentsDest = path.join(projectPath, 'agents');

    try {
      await execAsync(`cp -r "${agentsSource}" "${agentsDest}"`);
    } catch (copyError) {
      console.error('Error copying agents:', copyError);
      // Try alternative path
      const altAgentsSource = path.join(__dirname, '..', '..', '..', '..', '..', 'agents');
      await execAsync(`cp -r "${altAgentsSource}" "${agentsDest}"`);
    }

    // Generate and write files
    await fs.writeFile(path.join(projectPath, 'PROJECT_BRIEF.md'), generateProjectBrief(form));
    await fs.writeFile(path.join(projectPath, 'README.md'), generateReadme(form));
    await fs.writeFile(path.join(projectPath, '.gitignore'), generateGitignore());

    // Initialize git repository
    await execAsync(`cd "${projectPath}" && git init`);
    await execAsync(`cd "${projectPath}" && git add -A`);
    await execAsync(
      `cd "${projectPath}" && git commit -m "Initial commit: ${projectName}

- Added AI agent workflow system (10 agents)
- Created PROJECT_BRIEF with requirements
- Set up project structure

ðŸ¤– Generated with AI Agent Workflow System"`
    );

    let repoUrl: string | undefined;

    // Create GitHub repository if requested
    if (form.createGithubRepo) {
      const githubToken = process.env.GITHUB_TOKEN;

      if (!githubToken) {
        console.warn('GITHUB_TOKEN not set, skipping GitHub repo creation');
      } else {
        try {
          const octokit = new Octokit({ auth: githubToken });

          // Create repository
          const { data: repo } = await octokit.repos.createForAuthenticatedUser({
            name: projectName,
            description: form.description,
            private: form.repoVisibility === 'private',
            auto_init: false,
          });

          repoUrl = repo.html_url;

          // Add remote and push
          await execAsync(`cd "${projectPath}" && git remote add origin ${repo.clone_url}`);
          await execAsync(`cd "${projectPath}" && git branch -M main`);
          await execAsync(`cd "${projectPath}" && git push -u origin main`);

          console.log(`GitHub repository created: ${repoUrl}`);
        } catch (githubError) {
          console.error('Error creating GitHub repo:', githubError);
          // Don't fail the whole operation, just skip GitHub
        }
      }
    }

    res.json({
      success: true,
      localPath: projectPath,
      repoUrl,
      message: `Project "${projectName}" created successfully`,
    });
  } catch (error) {
    console.error('Error generating project:', error);
    res.status(500).json({
      error: 'Failed to generate project',
      details: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

// Get generation status (for future SSE implementation)
router.get('/generate-project/status/:id', async (req: Request, res: Response) => {
  // Placeholder for streaming status updates
  res.json({ status: 'not_implemented' });
});

export default router;
